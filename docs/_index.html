<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roulette</title>
  <!-- Highlight.js Theme: Atom One Light -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      background-color: #f4f4f9;
      max-width: 800px;
    }

    h2 {
      font-size: 120%;
      color: #34495e;
    }

    h3 {
      font-size: 110%;
      color: #2c3e50;
      margin-top: 20px;
      margin-bottom: 7px;
    }

    h4 {
      font-size: 105%;
      color: #617f9d;
      margin-top: 15px;
      margin-bottom: 0;
    }

    p {
      font-size: medium;
      margin: 1px;
    }

    nav {
      font-size: 90%;
    }

    .code-block {
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow: hidden;
      background-color: #fafafa;
      color: #333;
      margin-bottom: 20px;
    }

    .code-buttons {
      display: flex;
      background-color: #e8e8e8;
    }

    .code-buttons button {
      flex: 1;
      padding: 10px;
      cursor: pointer;
      background: #eaeaeb;
      color: #91929c;
      border: none;
      outline: none;
      font-size: 60%;
    }

    .code-buttons button.active {
      background: #e7f0f9;
      color: #7676a7;
    }

    pre {
      margin: 0;
      padding: 0;
      overflow-x: auto;
    }

    pre.js {
      display: none;
    }

    pre.ts {
      display: none;
    }

    pre.active {
      display: block;
    }

    .inline-code {
      font-family: monospace;
      background-color: #ededed;
      padding: 2px 4px;
      border-radius: 3px;
      color: #333;
      display: inline-block;
    }

    .spoiler {
      margin-bottom: 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow: hidden;
    }

    .spoiler-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background-color: #f4f4f4;
    }

    .spoiler-header h3 {
      margin: 0;
      font-size: 85%;
    }

    .spoiler-header h3:hover {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
    }

    .spoiler-header button {
      background: none;
      border: none;
      color: #007bff;
      text-decoration: underline;
      cursor: pointer;
      font-size: 85%;
    }

    .spoiler-header button:hover {
      color: #0056b3;
    }

    .spoiler-content {
      display: none;
      padding: 15px;
      background-color: #fff;
      border-top: 1px solid #ccc;
    }

    .notes {
      font-size: 80%;
    }
  </style>
</head>
<body>
  <h2>Roulette</h2>
  <p>A fast, lightweight, zero-dependency ts/js package that makes working with random numbers a breeze.</p>
  <nav>
    <h4>Table of content</h4>
    <ul>
      <li><a href="#distributions">Generating random numbers based on different distributions</a></li>
      <li>
        Picking a random element from an array
        <ul>
          <li><a href="#regular-roulette">based on these distributions.</a></li>
          <li><a href="#rigger-roulette">using probabilities you define yourself.</a></li>
        </ul>
      </li>
      <li>
        Appendixes
        <ul>
          <li><a href="#boosting-randomness">Boosting randomness</a></li>
        </ul>
      </li>
    </ul>
  </nav>
  <p>Simple, flexible, and ready to roll!</p>

  <section id="distributions">
    <p>The Roulette library offers nearly all popular probability distributions.</p>
    <p>To reduce bundle size, each random number provider can be imported separately.
      For instance, the Bernoulli distribution generator can be imported not only as:</p>
    <div class="code-block"><pre><code class="language-typescript">import { Bernoulli } from 'roulette';</code></pre></div>
    <p>but also as:</p>
    <div class="code-block"><pre><code class="language-typescript">import Bernoulli from 'roulette/Bernoulli';</code></pre></div>
    <p>This approach, when working with one or a few distributions, allows you to shrink the size of the imported
      code to just 150–500 bytes!</p>
    <p>Below is a list of all currently supported distributions, arranged alphabetically. Click on a distribution name
      to view details.</p>
  </section>

  <section id="sp1">
    <div class="spoiler">
      <div class="spoiler-header">
        <h3>sp1 header</h3>
        <div>
          <button class="show-button">Show</button>
          <button class="hide-button" style="display: none;">Hide</button>
        </div>
      </div>
      <div class="spoiler-content">
        <p>sp1 content</p>
      </div>
    </div>
  </section>

  <a href="#sp1">Go to Sp1</a>




  <section id="section-intro">
    <h2>Three minute introduction <span style="font-size: 16px; color: #898989;">(which covers 90% of use cases)</span></h2>
    <section id="uniform-distribution">
      <h3>Uniform distribution: <span style="font-size: 14px; color: #898989;">standard roulette</span></h3>
      <p>
        <strong>Q:</strong> Why would I need this package?<br/>
        <strong>A:</strong> It’s for picking a random element from a given array. Simple as that:
      </p>
      <div style="display: flex; margin: 10px 20px;">
        <img src="./pic1.png" width="150px" height="163px" style="padding-right: 20px;"/>
        <div>
          <div class="code-block">
            <div class="code-buttons">
              <button class="active" data-target="ts">TS</button>
              <button data-target="js">JS</button>
            </div>
            <pre class="ts active"><code class="language-typescript">import { Roulette } from &#39;roulette&#39;;

// Create a new instance of the Roulette class:
const roulette = new Roulette&#60;string&#62;();

// Then “mark the roulette sectors”
// (in other words, pass in your data array):
roulette.simpleBuildFrom([&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;white&#39;]);

// And after that, you can spin the roulette, getting
// a random element from the array each time:
let result = roulette.spin(); // result === &#39;red&#39;
result = roulette.spin(); // result === &#39;white&#39;
result = roulette.spin(); // result === &#39;blue&#39;</code></pre>
            <pre class="js"><code class="language-javascript">import { Roulette } from &#39;roulette&#39;;

// Create a new instance of the Roulette class:
const roulette = new Roulette();

// Then “mark the roulette sectors”
// (in other words, pass in your data array):
roulette.simpleBuildFrom([&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;white&#39;]);

// And after that, you can spin the roulette, getting
// a random element from the array each time:
let result = roulette.spin(); // result === &#39;red&#39;
result = roulette.spin(); // result === &#39;white&#39;
result = roulette.spin(); // result === &#39;blue&#39;</code></pre>
          </div>
        </div>
      </div>

      <p>
        <strong>Q:</strong> Wait, that’s it? Why would I bother with this package when I could just use a simple one-liner function?<br/>
        <strong>A:</strong> Of course not — that’s just scratching the surface. This is the most basic use case. The Roulette package
          gives you full control over the relative probabilities of each element in your array being picked. The probability
          distribution can either be <a href="#stat-non-uniform-dist">stationary</a> (staying consistent for all spins) or
          <a href="#dynamic-non-uniform-distribution">dynamic</a> (changing after each spin).
      </p>
    </section>
    <section id="stat-non-uniform-dist">
      <h3>Stationary Non-Uniform distribution: <span style="font-size: 14px; color: #898989;">a rigged roulette</span></h3>

      <p>Let’s recap: we create a new instance of the roulette and then call the
        <span class="inline-code language-javascript">roulette.simpleBuildFrom()</span> method. This method divides the roulette wheel into <strong>N</strong>
        equally sized sectors, where <strong>N</strong> is the length of the array you provide. When you spin the roulette
        (by calling <span class="inline-code language-javascript">roulette.spin()</span>), each sector is selected randomly with an equal probability.
      </p>
      <p>Now, imagine a roulette wheel where the sectors have different sizes.</p>
      <p>
        <strong>Q:</strong> Oh, so that’s how casinos make their money? That’s outright cheating!<br/>
        <strong>A:</strong> Exactly, it’s cheating. The wider the sector, the more often it will come up, right? If sector
        is three times narrower than sector <strong>B</strong>, then it will appear three times less often
        when you spin the roulette.
      </p>
      <p>The roulette abstraction allows us to set the probability distribution for each sector almost as easily as setting
        an equal probability. You just need to specify the &#34;width of sector&#34; for the each element in your input data set.
      </p>
      <p>
        <strong>Q:</strong> What values can I use for the widths?<br/>
        <strong>A:</strong> Any non-negative numbers. It’s not the actual values that matter but their ratios. The probability of a sector being selected is calculated as:
        <strong>(width of the sector) / (sum of all sector widths)</strong>.<br/>
        For example, zero-width sectors will never show up.<br/>
        To describe sectors with different widths, the roulette comes with the <span class="inline-code language-javascript">buildFrom()</span> method:
      </p>
      <div style="display: flex;">
        <img src="./pic2.png" width="210px" height="220px" style="padding-right: 20px;"/>
        <div>
          <div class="code-block">
            <div class="code-buttons">
              <button class="active" data-target="ts">TS</button>
              <button data-target="js">JS</button>
            </div>
            <pre class="ts active"><code class="language-typescript">import { Roulette } from &#39;roulette&#39;;

// Create a new instance of the Roulette class:
const roulette = new Roulette&#60;string&#62;();

// Then “mark the roulette sectors”
roulette.buildFrom([
  {v: &#39;a&#39;, w: 4},
  {v: &#39;b&#39;, w: 3},
  {v: &#39;c&#39;, w: 5},
  {v: &#39;d&#39;, w: 4}
]);

// And after that, you can spin the roulette:
let result = roulette.spin(); // result === &#39;c&#39;
result = roulette.spin(); // result === &#39;d&#39;
result = roulette.spin(); // result === &#39;c&#39;</code></pre>
            <pre class="js"><code class="language-javascript">import { Roulette } from &#39;roulette&#39;;

// Create a new instance of the Roulette class:
const roulette = new Roulette();

// Then “mark the roulette sectors”
roulette.buildFrom([
  {v: &#39;a&#39;, w: 4},
  {v: &#39;b&#39;, w: 3},
  {v: &#39;c&#39;, w: 5},
  {v: &#39;d&#39;, w: 4}
]);

// And after that, you can spin the roulette:
let result = roulette.spin(); // result === &#39;c&#39;
result = roulette.spin(); // result === &#39;d&#39;
result = roulette.spin(); // result === &#39;c&#39;</code></pre>
          </div>
        </div>
      </div>
    </section>
    <section id="three-dataset-form">
      <p>
        So, Roulette has two alternative builders: <span class="inline-code language-javascript">roulette.simpleBuildFrom()</span> and <span class="inline-code language-javascript">roulette.buildFrom()</span>.<br/>
        Parameter of <span class="inline-code language-javascript">roulette.simpleBuildFrom()</span> is an array of item values.<br/>
        The elements in your dataset for <span class="inline-code language-javascript">roulette.buildFrom()</span> can be written in one of three equivalent styles — just pick whichever feels more natural to you:
      </p>
      <ul>
        <li>
          An object: {value: ..., width: 	&#60;non-negative number&#62;}:<br/>
          <span class="inline-code language-javascript">roulette.buildFrom([{value: &#39;a&#39;, width: 1}, ..., {value: false, width: 7.5}]);</span>
        </li>
        <li>
          A shorthand object: {v: ..., w: &#60;non-negative number&#62;}, where v is the value, and w is the width:<br/>
          <span class="inline-code language-javascript">roulette.buildFrom([{v: {type: &#39;fish&#39;}, w: 9.7}, ..., {v: [1, &#39;k&#39;], width: 35}]);</span>
        </li>
        <li>
          Or just a simple array with two elements: [value, width]:<br/>
          <span class="inline-code language-javascript">roulette.buildFrom([[true, 3], ..., [Symbol(), 26]]);</span>
        </li>
      </ul>
      <p>In any case, <span class="inline-code language-javascript">roulette.spin()</span> returns a value of random item.</p>
    </section>
    That’s it for the three-minute intro! Now we’re diving into the advanced features, all powered by the "entropy provider".</p>
  </section>
  <section id="entropy-provider">
    <h2>Entropy provider</h2>
    <p>The Roulette class constructor can take one parameter: an entropy provider. It serves a few purposes.
      Let’s break them down one by one.</p>
    <section id="randomizer">
      <h3>Secure randomness</h3>
      <p>By default, Roulette uses the built-in JavaScript function <span class="inline-code language-javascript">Math.random()</span>,
        because it’s the only one available on all platforms. But the numbers it gives are only “random” if you really
        stretch the definition.</p>
      <div class="spoiler">
        <div class="spoiler-header">
          <h3>What’s wrong with <span class="inline-code language-javascript">Math.random()</span>?</h3>
          <div>
            <button class="show-button">Show</button>
            <button class="hide-button" style="display: none;">Hide</button>
          </div>
        </div>
        <div class="spoiler-content">
          <ol>
            <li>
              <strong>It’s not truly random.</strong>
              <ul><li>
                <span class="inline-code language-javascript">Math.random()</span> is a pseudorandom number generator,
                which means it’s based on a set algorithm. It’s predictable at its core. For everyday tasks, it’s fine,
                but for anything requiring high precision or real randomness, this won’t cut it.
              </li></ul>
            </li>
            <li>
              <strong>No control over the seed.</strong>
              <ul><li>
                You can’t set or reset a seed, so you can’t reproduce the same sequence of numbers. This makes it tricky
                for testing or simulations where repeatability is a must.
              </li></ul>
            </li>
            <li>
              <strong>Not secure.</strong>
              <ul><li>
                It’s not designed for cryptography. If you’re generating keys, tokens, or anything sensitive,
                <span class="inline-code language-javascript">Math.random()</span> islike leaving your front door wide
                open. Use something like <span class="inline-code language-javascript">crypto.getRandomValues()</span> instead.
              </li></ul>
            </li>
            <li>
              <strong>Browser-dependent quirks.</strong>
              <ul><li>
                Different browsers and environments (like Node.js) may implement Math.random() slightly differently, so
                the results might not always match.
              </li></ul>
            </li>
            <li>
              <strong>Weak with big datasets.</strong>
              <ul><li>
                If you’re working with large arrays or need highly random results for stats, Math.random() can show
                patterns, which isn’t great.
              </li></ul>
            </li>
            <li>
              <strong>Not the fastest.</strong>
              <ul><li>
                For high-performance tasks, like generating tons of random numbers quickly, it’s not the best choice.
              </li></ul>
            </li>
          </ol>
        </div>
      </div>
      <p>So, if you’re running the code on a platform with a better random number function, it’s a good idea
        to use that instead.
      </p>
    </section>
    <section id="dynamic-non-uniform-distribution">
      <h3>Dynamic Non-Uniform distribution</h3>
      <p>But what if we want to dynamically change the probability distribution with each spin (from one call
        to <span class="inline-code language-javascript">roulette.spin()</span> to the next)? Or maybe save a seed
        to ensure repeatable results (like for testing)?
      </p>
      <p>Our "entropy provider" is perfect for that too.</p>
      <p>Now that we know what it’s for, let’s talk about how it actually works.</p>
    </section>
    <section id="e-provider-in-detail">
      <h3>The Entropy Provider in Detail</h3>
      <p>The Roulette class constructor takes one optional parameter: the entropy provider.
        This is a function that accepts three <strong>optional</strong> parameters:</p>
        <ul>
          <li>
            <p>
              <strong>dataset:</strong><br/>
              This is a current copy of the dataset you passed to either
              <span class="inline-code language-javascript">roulette.simpleBuildFrom()</span> or
              <span class="inline-code language-javascript">roulette.buildFrom()</span>.
            </p>
            <img src="./notes-70x78.png" height="70px" width="78px" style="float:left">
            <ul class="notes">
              <li>Regardless of which builder you used or how you passed the dataset elements into
                <span class="inline-code language-javascript">roulette.buildFrom()</span> (in any of the
                <a href="#three-dataset-form">three supported forms</a>), the entropy provider will always receive them
                as an array of shorthand objects: <span class="inline-code language-javascript">{v: any, w: number}</span>.
                If you used <span class="inline-code language-javascript">roulette.simpleBuildFrom()</span>, all elements
                will have their <span class="inline-code language-javascript">w</span> field set to 1.
              </li>
              <li>
                If you haven’t called any of the builders, the <span class="inline-code language-javascript">dataset</span>
                will be <span class="inline-code language-javascript">undefined</span>. In this case, the entropy
                provider is expected to build and return the dataset on its own (see the &#34;return&#34; section
                for more information).
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong>storage:</strong><br>
              Roulette provides an internal storage where the entropy provider can store arbitrary information between
              calls. You can (but are not required to) explicitly initialize this storage by calling
              <span class="inline-code language-javascript">roulette.setStorage(storage)</span>.
            </p>
            <ul class="notes"><li>
              If the storage hasn’t been initialized using
              <span class="inline-code language-javascript">roulette.setStorage(storage)</span> or set by the entropy
              provider, value of this parameter is <span class="inline-code language-javascript">undefined</span>.
            </li></ul>
          </li>
          <li>
            <p>
              <strong>spinParams:</strong><br/>
              <span class="inline-code language-javascript">roulette.spin</span> takes an one optional parameter:
              <span class="inline-code language-javascript">roulette.spin(spinParams)</span>, which is a convenient
              way to pass arbitrary information to the entropy provider related to a specific spin of the roulette.
            </p>
          </li>
        </ul>
        <section id="e-provider-return">
          <h4>Return</h4>
          <p>The entropy provider should return one of the following:</p>
          <ul>
            <li>
              <p>
                <strong>A number</strong> in the range from 0 (inclusive) to 1 (exclusive).<br/>
                This option works well when we simply want to improve randomness.<br/>
                For example, if our code runs in a <span class="inline-code language-javascript">Node.js</span> environment,
                we can replace the default entropy provider <span class="inline-code language-javascript">Math.random</span>
                in Roulette with the better <span class="inline-code language-javascript">crypto.randomInt</span>.
              </p>
              <div>
                <img src="./notes-70x78.png" height="70px" width="78px" style="float:left">
                <ul class="notes">
                  <li>
                    Remember, we need to scale the result to the range 0...1.
                  </li>
                  <li>
                    Note: You should pass the function itself to the constructor (without parentheses), not execute it!
                  </li>
                </ul>
                <br style="float: none;"/>
              </div>
              <p>So, let’s do it!</p>
              <div class="code-block">
                <div class="code-buttons">
                  <button class="active" data-target="ts">TS</button>
                  <button data-target="js">JS</button>
                </div>
                <pre class="ts active"><code class="language-typescript">import { Roulette, SyncEntropyProvider } from &#39;roulette&#39;;

// Define our new entropy provider:
const entropyProvider: SyncEntropyProvider = () => {
  const maxNumber = Math.pow(2, 47);
  return crypto.randomInt(maxNumber) / maxNumber;
}

// Define the dataset:
const dataset: string[] = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;white&#39;];

// Create a new instance of the Roulette class:
const roulette = new Roulette&#60;string&#62;(entropyProvider);

// Then “mark the roulette sectors”
// (in other words, pass in your data array):
roulette.simpleBuildFrom();

// And after that, you can spin the roulette, getting
// a random element from the array each time:
let result = roulette.spin(); // result === &#39;red&#39;
result = roulette.spin(); // result === &#39;white&#39;
result = roulette.spin(); // result === &#39;blue&#39;</code></pre>
            <pre class="js"><code class="language-javascript">import { Roulette } from &#39;roulette&#39;;

// Define our new entropy provider:
const entropyProvider = () => {
  const maxNumber = Math.pow(2, 47);
  return crypto.randomInt(maxNumber) / maxNumber;
}

// Define the dataset:
const dataset = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;white&#39;];

// Create a new instance of the Roulette class:
const roulette = new Roulette(entropyProvider);

// Then “mark the roulette sectors”
// (in other words, pass in your data array):
roulette.simpleBuildFrom();

// And after that, you can spin the roulette, getting
// a random element from the array each time:
let result = roulette.spin(); // result === &#39;red&#39;
result = roulette.spin(); // result === &#39;white&#39;
result = roulette.spin(); // result === &#39;blue&#39;</code></pre>
              </div>
              <p>Ok, it works.
                But… our code looks kinda silly: every time we spin the roulette (every time
                <code class="language-typescript">entropyProvider()</code> is called), we’re recalculating the same
                constant <code class="language-typescript">maxNumber</code>, over and over.
                Let’s fix that by calculating it just once, storing it in the storage, and letting
                <code class="language-typescript">entropyProvider</code> grab it from there:</p>
                <div class="code-block">
                  <div class="code-buttons">
                    <button class="active" data-target="ts">TS</button>
                    <button data-target="js">JS</button>
                  </div>
                  <pre class="ts active"><code class="language-typescript">import { Roulette, SyncEntropyProvider } from &#39;roulette&#39;;
const maxNumber = Math.pow(2, 47);

// Define our new entropy provider:
const entropyProvider: SyncEntropyProvider =
  (_dataset, maxNumber) => crypto.randomInt(maxNumber) / maxNumber;

// Define the dataset:
const dataset: string[] = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;white&#39;];

// Create a new instance of the Roulette class:
const roulette = new Roulette&#60;string, undefined, number&#62;(entropyProvider);

// Set storage with maxNumber
roulette.setStorage(maxNumber);

// Mark the roulette sectors
// (in other words, pass in your data array):
roulette.simpleBuildFrom(dataset);

// And after that, you can spin the roulette, getting
// a random element from the array each time:
let result = roulette.spin(); // result === &#39;red&#39;
result = roulette.spin(); // result === &#39;white&#39;
result = roulette.spin(); // result === &#39;blue&#39;</code></pre>
            <pre class="js"><code class="language-javascript">import { Roulette } from &#39;roulette&#39;;

const maxNumber = Math.pow(2, 47);

// Define our new entropy provider:
const entropyProvider =
  (_dataset, maxNumber) => crypto.randomInt(maxNumber) / maxNumber;

// Define the dataset:
const dataset = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;white&#39;];

// Create a new instance of the Roulette class:
const roulette = new Roulette(entropyProvider);

// Set storage with maxNumber
roulette.setStorage(maxNumber);

// Mark the roulette sectors
// (in other words, pass in your data array):
roulette.simpleBuildFrom(dataset);

// And after that, you can spin the roulette, getting
// a random element from the array each time:
let result = roulette.spin(); // result === &#39;red&#39;
result = roulette.spin(); // result === &#39;white&#39;
result = roulette.spin(); // result === &#39;blue&#39;</code></pre>
                </div>
            </li>
            <li>
              <p><strong>An object</strong> with one mandatory and two optional fields:</p>
            </li>
          </ul>
        </section>
    </section>
  </section>

<script>
  // Initialize Highlight.js
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('pre code, .inline-code').forEach((block) => {
      hljs.highlightElement(block);
    });
  });

  // Global language switching for all blocks
  document.querySelectorAll('.code-buttons button').forEach(button => {
    button.addEventListener('click', () => {
      const target = button.getAttribute('data-target');

      // Update buttons globally
      document.querySelectorAll('.code-buttons button').forEach(btn => {
        if (btn.getAttribute('data-target') === target) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      // Update code blocks globally
      document.querySelectorAll('.code-block').forEach(block => {
        block.querySelectorAll('pre').forEach(pre => pre.classList.remove('active'));
        block.querySelector(`pre.${target}`).classList.add('active');
        hljs.highlightElement(block.querySelector(`pre.${target} code`));
      });
    });
  });

  // Select all spoilers
  const spoilers = document.querySelectorAll('.spoiler');

  spoilers.forEach(spoiler => {
    const showButton = spoiler.querySelector('.show-button');
    const hideButton = spoiler.querySelector('.hide-button');
    const header = spoiler.querySelector('.spoiler-header');
    const content = spoiler.querySelector('.spoiler-content');

    content.style.display = 'none';

    header.addEventListener('click', () => {
      content.style.display = content.style.display === 'none' ? 'block' : 'none';
      showButton.style.display = content.style.display === 'none' ? 'inline' : 'none';
      hideButton.style.display = content.style.display === 'none' ? 'none' : 'inline';
    });

    // Show content
    showButton.addEventListener('click', () => {
      content.style.display = 'block';
      showButton.style.display = 'none';
      hideButton.style.display = 'inline';
    });

    // Hide content
    hideButton.addEventListener('click', () => {
      content.style.display = 'none';
      showButton.style.display = 'inline';
      hideButton.style.display = 'none';
    });
  });

  const openSpoilerFromHash = () => {
    const hash = window.location.hash;

    if (hash) {
      const targetSection = document.querySelector(hash);
      if (targetSection) {
        const spoilerContent = targetSection.querySelector('.spoiler-content');
        const showButton = targetSection.querySelector('.show-button');
        const hideButton = targetSection.querySelector('.hide-button');

        spoilerContent.style.display = 'block';
        showButton.style.display = 'none';
        hideButton.style.display = 'inline';
        targetSection.scrollIntoView({ behavior: 'smooth' }); // Smooth scrolling
      }
    }
  };
  // Open spoiler on hash change
  window.addEventListener('hashchange', openSpoilerFromHash);
  let currentHash = window.location.hash;

  setInterval(() => {
    if (currentHash !== window.location.hash) {
      currentHash = window.location.hash;
      openSpoilerFromHash();
    }
  }, 100);
</script>

</body>
</html>
